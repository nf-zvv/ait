# Введение в JavaScript

JavaScript — это кросс-платформенный, объектно-ориентированный скриптовый язык. JavaScript (JS) в основном используется для создания динамических скриптов на веб-страницах, но он так же часто применяется на стороне сервера, используя пакеты, такие как `Node.JS`.

JavaScript входит в базовую триаду технологий, которые необходимо знать всем разработчикам веб-приложений: HTML (определение содержимого веб-страниц), CSS (определение внешнего вида веб-страниц), JavaScript (определение поведения веб-страниц).

1. Ознакомиться с синтаксисом JavaScript.
2. Ознакомиться с типами данных JavaScript.
3. Ознакомиться с переменными JavaScript.
4. Ознакомиться с операторами и выражениями JavaScript.
4. Способы внедрения JavaScript-кода в веб-страницы.
5. Способы вывода (отображения) информации.

## Задание

1. Создайте новую html-страницу со встроенным JavaScript-кодом.
1. Изучите поведение оператора "+": как он работает с числами, как - со строками. Напишите код, который наглядно проиллюстрирует ваше исследование.
2. Проведите исследование, которое ответит на вопрос - что будет, если есть глобальная переменная с именем, допустим, `x`, и в функции объявлена переменная с таким же именем. Что если функция попытается изменить эту переменную - к которой из них будет обращение?
3. Напишите функцию, которая по размерам комнаты (ширина, длина, высота) возвращает площадь стен комнаты.
4. Затем примените ее в программе, которая по размерам комнаты вычисляет - сколько нужно взять рулонов обоев, чтобы оклеить эту комнату? Размеры рулона тоже, разумеется, нужно задать.


## Особенности JavaScript

 - Для написания JavaScript-программы используется набор символов Unicode.
 - JavaScript чувствителен к регистру символов. Это означает, что ключевые слова, имена переменных и функций и любые другие инедтификаторы должны вводится в строго заданном регистре. Например, `online`, `Online`, `OnLine` и `ONLINE` - это четыре разных переменные.
 - JavaScript игнорирует пробелы, которые могут присутствовать между лексемами в программе. Кроме того, JavaScript также по большей части игнорирует символы перевода строки. Поэтому пробелы и символы перевода строки могут без ограничений использоваться в исходных текстах программ для форматирования и придания им удобочитаемого внешнего вида.
 - Необязательные точки с запятой. Обычно в JavaScript точку с запятой между инструкциями можно не ставить, если они находятся в разных строках. (Точку с запятой можно также опустить в конце программы или если следующей лексемой в программе является закрывающая фигурная скобка }.) Многие программисты на JavaScript используют точки с запятой для явного обозначения концов инструкций, даже если в этом нет необходимости.

## Типы данных

Типы данных в JavaScript можно разделить на две категории: простые типы и объекты.

![JS datatypes](/img/JS-datatypes.png)

### Числа

В отличие от многих языков программирования, в JavaScript не делается различий между целыми и вещественными значениями. В программе JavaScript все числа представлены 64-разрядными значениями с плавающей точкой (формат IEEE 754).

Помимо десятичных целых литералов JavaScript распознает шестнадцатеричные значения. Шестнадцатеричные литералы начинаются с последовательности символов `0x`, за которой следует строка шестнадцатеричных цифр.

Пример:

```javascript
   var a = 255;
   var b = 0xFF;  // Число 255 в шестнадцатеричной системе исчисления
   var c = 16.75;
   var d = 2e4;  // 2 * 10^4 = 20 000
```

Ключевым словом `var` выполняется объявление переменной. 

#### Арифметические операции

Обработка чисел в языке JavaScript выполняется с помощью арифметических операторов. В число таких операторов входят: оператор сложения `+`, оператор вычитания `-` , оператор умножения `*`, оператор деления `/` и оператор деления по модулю `%` (возвращает остаток от деления).

Помимо этих простых арифметических операторов JavaScript поддерживает более сложные математические операции, с помощью функций и констант, доступных в виде свойств объекта Math:

```javascript
Math.pow(2,53)            // 2 в степени 53
Math.round(.6)            // Округление до ближайшего целого (результат 1.0)
Math.ceil(.6)             // Округление вверх (результат 1.0)
Math.floor(.6)            // Округление вниз (результат 0)
Math.abs(-5)              // Модуль числа (результат 5)
Math.max(x,y,z)           // Возвращает наибольший аргумент
Math.min(x,y,z)           // Возвращает наименьший аргумент
Math.random()             // Псевдослучайное число x, где 0 <= x < 1.0
Math.PI                   // Длина окружности (3.1415)
Math.E                    // Основание натурального логарифма (2.71)
Math.sqrt(3)              // Корень квадратный из 3
Math.pow(3, 1/3)          // Корень кубический из 3
Math.sin(0)               // Тригонометрия: имеются также Math.cos, Math.atan и другие
Math.log(10)              // Натуральный логарифм 10
Math.log(100)/Math.LN10   // Логарифм 100 по основанию 10 (десятичный)
Math.log(512)/Math.LN2    // Логарифм 512 по основанию 2
Math.exp(3)               // Экспонента, Math.E в кубе
```

#### Infinity, -Infinity, NaN

Деление на ноль не считается ошибкой в JavaScript: в этом случае просто возвращается бесконечность (`Infinity`) или отрицательная бесконечность (`-Infinity`).

Однако есть одно исключение: операция деления нуля на ноль не имеет четко определенного значения, поэтому в качестве результата такой операции возвращается специальное значение «не число» (not-a-number), которое обозначается как `NaN`. Значение `NaN` возвращается также при попытке разделить бесконечность на бесконечность, извлечь квадратный корень из отрицательного числа или выполнить арифметическую операцию с нечисловыми операндами, которые не могут быть преобразованы в числа.

`NaN` в JavaScript обладает одной необычной особенностью: оно не равно никакому другому значению, включая себя же. Чтобы выяснить, содержит ли переменная `x`  значение `NaN`, нужно записать: `x!=x`. Данное выражение вернет `true`, если `x`  равно `NaN`. Можно также применить функцию `isNaN()`, которая вернет `true`, если аргумент  равен `NaN`.


### Строки

Строка - это неизменяемая, упорядоченная последовательность 16-битных значений, каждое из которых обычно представляет символ Юникода. Длина строки - это количество 16-битных значений, содержащихся в ней. Нумерация символов в строках (и элементов в массивах) в языке JavaScript начинается с нуля. 

Чтобы включить литерал строки в JavaScript-программу, достаточно просто заключить символы строки в парные одинарные или двойные кавычки (`'` или `"`). Символы двойных кавычек могут содержаться в строках, ограниченных символами одинарных кавычек, а символы одинарных кавычек - в строках, ограниченных символами двойных кавычек.

В языке JavaScript нет специального типа для представления единственного элемента строки. Для представления единственного 16-битного значения просто используется строка с длиной, равной 1.

Одной из встроенных возможностей JavaScript является способность конкатенировать строки. Если оператор `+` применяется к числам, они складываются, а если к строкам - они объединяются, при этом вторая строка добавляется в конец первой.

Пример:

```js
var str = "";   // Пустая строка
str = 'простая строка';
str = 'строка с "кавычками" внутри';

var str2 = 'Hello, ' + 'world!';     // Получается строка Hello, world!

// Конкатенация строки с переменной
var name = 'Александр';
str2 = 'Добро пожаловать, ' + name + '!';
```

#### ESC-последовательности

Символ обратного слеша (`\`) имеет специальное назначение в JavaScript-строках. Вместе с символами, следующими за ним, он обозначает символ, не представимый внутри строки другими способами. Например, `\n` - это управляющая последовательность (escape sequence), обозначающая символ перевода строки.

```js
str = 'В этом строковом литерале\nдве строки';
```

## Встраивание JavaScript-кода в HTML-документы

Клиентский JavaScript-код может встраиваться в HTML-документы четырьмя способами:

1. встроенные сценарии между парой тегов `<script>` и `</script>`;
2. из внешнего файла, заданного атрибутом src тега `<script>`;
3. в обработчик события, заданный в качестве значения HTML-атрибута, такого как `onclick` или `onmouseover`;
4. как тело URL-адреса, использующего специальный спецификатор псевдопротокола `javascript:`.

### Элемент <script>

Клиентские JavaScript-сценарии могут встраиваться в HTML-файлы между тегами <script> и </script>:


```html
<script>
  // Здесь располагается JavaScript-код
</script>
```

### Сценарии во внешних файлах

Тег `<script>` поддерживает атрибут `src`, который определяет URL-адрес файла, содержащего JavaScript-код. Используется он следующим образом:

```html
  <script src="../../scripts/myscript.js"></script>
```

Файл JavaScript-кода обычно имеет расширение `.js` и содержит JavaScript-код в «чистом виде» без тегов `<script>` или любого другого HTML-кода.

Тег `<script>` с атрибутом `src` ведет себя точно так, как если бы содержимое указанного файла JavaScript-кода находилось непосредственно между тегами `<script>` и `</script>`, любое содержимое между открывающим и закрывающим тегами `<script>` игнорируется. Обратите внимание, что закрывающий тег `</script>` обязателен, даже когда указан атрибут `src` и между тегами отсутствует JavaScript-код.

### Обработчики событий в HTML

JavaScript-код, расположенный в теге `<script>`, исполняется один раз, когда содержащий его HTML-файл считывается в веб-браузер. Для обеспечения интерактивности программы на языке JavaScript должны определять обработчики событий - JavaScript-функции, которые регистрируются в веб-браузере и автоматически вызываются веб-браузером в ответ на определенные события (такие как ввод данных пользователем).

JavaScript-код может регистрировать обработчики событий, присваивая функции свойствам объектов `Element` (таким как `onclick` или `onmouseover`), представляющих HTML-элементы в документе.

Свойства обработчиков событий, такие как `onclick`, отражают HTML-атрибуты с теми же именами, что позволяет определять обработчики событий, помещая JavaScript-код в HTML-атрибуты. Например:

```html
<button onClick="alert('Привет')">Щелкните меня!</button>
```

Обратите внимание на атрибут `onClick`. JavaScript-код, являющийся значением этого атрибута, будет выполняться всякий раз, когда пользователь будет щелкать на кнопке.

Пример для гиперссылки:

```html
<a href="#" onclick="alert('Пример 1 сработал'); return false;">Пример 1</a>
```

**Выносим код события onclick в javascript-функцию**

Следующий способ хорош тем, что мы отделяем javascript-код от html тегов. В теге прописываем название функции, а саму функцию выносим в отдельный блок:

```javascript
<script>
function ChangeColor(Element) {
	if (Element.style.color == 'green') Element.style.color = 'red';
	else Element.style.color = 'green';
	return false;
}
</script>

<a href="#" style="color: green;" onclick="return ChangeColor(this);">Изменить цвет</a>
```

**Вешаем onclick на элемент из javascript-кода**

Этот способ хорош тем, что событие можно повесить на множество элементов. Для этого требуется выбрать при помощи javascript-селекторов элементы, к которым требуется применить событие onclick.

```javascript
<script>
//дожидаемся полной загрузки страницы
window.onload = function () {
    //получаем идентификатор элемента
    var a = document.getElementById('switch');
    
    //вешаем на него событие
    a.onclick = function() {
        //производим какие-то действия
        if (this.innerHTML=='On') this.innerHTML = 'Off';
        else this.innerHTML = 'On';
        //предотвращаем переход по ссылке href
        return false;
    }
}
</script>

<a id="switch" href="#">On</a>
```

### JavaScript в URL

Еще один способ выполнения JavaScript-кода на стороне клиента - включение этого кода в URL-адресе вслед за спецификатором псевдопротокола `javascript:`. Этот специальный тип протокола обозначает, что тело URL-адреса представляет собою произвольный JavaScript-код, который должен быть выполнен интерпретатором JavaScript. Он интерпретируется как единственная строка, и потому инструкции в ней должны быть отделены друг от друга точками с запятой.

URL вида `javascript:` можно использовать везде, где допускается указывать обычные URL: в атрибуте `href` тега `<a>`, в атрибуте `action` тега `<form>` и даже как аргумент метода, такого как `window.open()`. Например, адрес URL с программным кодом на языке JavaScript в гиперссылке может иметь такой вид:

```html
<a href="JavaScript:new Date().toLocaleTimeString();">
    Который сейчас час?
</a>
```

## DOM (Document Object Model)

Согласно DOM-модели, документ является иерархией.

![DOM](/img/dom.jpg)

Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы. По существу, DOM соединяет веб-страницу с языками описания сценариев либо языками программирования.

Проще говоря, DOM - это представление документа в виде дерева тегов. Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Пример:

```html
<html>
<head>
  <title>My HTML Document</title>
</head>
<body>
  <h1>Heading</h1>
  <div id="div1">
    <p>P Tag 1</p>
  </div>
  <div id="div2">
    <div class="p2">P Tag 2</div>
  </div>
</body>
</html>
```

Дерево DOM для кода, представленного выше, будет выглядеть следующим образом:

![DOM Example](/img/dom_example.jpg)

Корневым элементом иерархии является `html`. У него есть два потомка. Первый - `head`, второй - `body`. И так далее, каждый вложенный тег является потомком тега выше.

Теги образуют *узлы-элементы* (element node). Текст представлен *текстовыми узлами* (text node). И то и другое - равноправные узлы дерева DOM.

Без DOM язык JavaScript не имел бы никакой модели или представления о веб-странице, HTML-документе и их элементах. Каждый элемент в документе - весь документ в целом, заголовок, таблицы внутри документа, заголовки таблицы, текст внутри ячеек таблицы - это части объектной документной модели для этого документа, поэтому все они могут быть доступны и могут изменяться с помощью DOM и скриптового языка наподобие JavaScript.

### Работа с DOM

Объект `window` представляет собой окно [браузера], содержащее DOM документ.

Для манипуляций с DOM используется объект `document`. Используя `document`, можно получать нужный элемент дерева и менять его содержание.

`document.documentElement` - самый верхний тег. В случае корректной HTML-страницы, это будет `<html>`.

`document.body` - тег `<body>`.

С вершины дерева DOM можно пойти дальше вниз. Для этого каждый DOM-узел содержит массив всех детей, отдельно - ссылки на первого и последнего ребенка и еще ряд полезных свойств.

Все дочерние элементы, включая текстовые находятся в массиве `childNodes`.

Свойства `firstChild` и `lastChild` показывают на первый и последний дочерние элементы и равны `null`, если детей нет.

Свойство `parentNode` указывает на родителя. Например, для `<body>` таким элементом является `<html>`.

Свойства `previousSibling` и `nextSibling` указывают на левого и правого братьев узла.

### Свойства элементов

У DOM-элементов есть масса свойств. Некоторые из них можно читать и устанавливать, другие - только читать.

 - `tagName` - имя тега в верхнем регистре, только для чтения;
 - `style` - Это свойство управляет стилем. Оно аналогично установке стиля в CSS. Есть общее правило замены - если CSS-атрибут имеет дефисы, то для установки `style` нужно заменить их на верхний регистр букв. Например, для установки свойства `z-index` в 1000, нужно поставить: `element.style.zIndex = 1000`;
 - `innerHTML` - содержит весь HTML-код внутри узла, и его можно менять. Свойство `innerHTML` применяется, в основном, для динамического изменения содержания страницы;
 - `className` - задает класс элемента. Оно полностью аналогично html-атрибуту `class`;
 - `onclick`, `onkeypress`, `onfocus` - функции-обработчики соответствующих событий. Например, можно присвоить обработчик события `onclick`.

### Выбор элементов документа

Обычно программа на JavaScript на стороне клиента решает свои задачи путем манипулирования одним или несколькими элементами документа. В модели DOM есть ряд способов выбора элемента:

 - по идентификатору (атрибут `id`);
 - по имени (атрибут `name`);
 - по имени тега;
 - по классу или классам CSS (атрибут `class`);
 - по соответствию заданому селектору CSS.

#### Выбор элемента по идентификатору

Каждый элемент HTML имеет атрибут `id`. Значение атрибута должно быть уникальным во всём документе. Выбрать элемент на основе уникального значения `id` можно с помощью метода `getElementById()` объекта `Document`.

```html
<div id="container"></div>
```

```javascript
var elem = document.getElementById("container");
```

#### Выбор элементов по имени

Атрибут `name` изначально был предназначен для присвоения имён элементам форм. Значение атрибута `name` используется при передаче данных формы на сервер. Как и атрибут `id`, атрибут `name` используется для присвоения имени элементу. Однако в отличие от `id`, значение атрибута `name` не обязательно должно быть уникальным. Кроме того, в отличие от атрибута `id`, атрибут `name` допустим только в подмножестве элементов HTML, в которое входят формы, элементы форм и элементы `<iframe>` и `<img>`.

```html
<form name="shipping_address">
	<input name="city" value="Izhevsk">
</form>
```

```javascript
var city = document.getElementsByName("city");
```

Метод `getElementsByName()` возвращает объект `NodeList`, который работает как массив объектов `Element`, доступный только для чтения.

Также элементы можно выбирать по имени посредством свойств объекта `Document`, имеющих соответствующие имена. Например на основе кода HTML приведенного выше:

```javascript
var city = document.shipping_address.city;
```

#### Выбор элементов по имени тега

Выбирать элементы можно также по их типу, имени тега (иногда пишут "по имени дескриптора") с помощью метода `getElementsByTagName()` объекта `Document`. Например, получить массивоподобный объект, содержащий все объекты `Element` всех элементов `<span>`, присутствующих в документе:

```javascript
var spans = document.getElementsByTagName("span");
```

Метод `getElementsByTagName()` возвращает объект `HTMLCollection`. Элементы объекта `HTMLCollection` расположены в том же порядке, что и в документе. Например, первый элемент `<p>` можно получить следующим образом:

```javascript
var firstP = document.getElementsByTagName("p")[0];
```

Метод `getElementsByTagName()` определен не только в классе `Document`, но и в классе `Element`. Это значит, что он может выбирать только элементы, являющиеся потомками элемента, через который вызван метод. Например, найти все элементы `<span>`, находящиеся в пермом элементе `<p>`:

```javascript
var firstP = document.getElementsByTagName("p")[0];
var firstSpans = firstP.getElementsByTagName("span")
```

#### Выбор элементов по классам CSS

Метод `getElementsByClassName()` возвращает массивоподобный (итерируемый) объект всех дочерних элементов, соответствующих всем из указанных имён классов.

Как и `getElementsByTagName()`, метод `getElementsByClassName()` можно вызывать либо через документ, либо через элемент.

```javascript
// Поиск всех элементов с классом warning
var w = document.getElementsByClassName("warning");
// Поиск потомков классов fatal и error элемента с идентификатором log
var log = document.getElementById("log");
var fatal = log.getElementsByClassName("falat error");
```

Метод `getElementsByClassName()` возвращает текущую `HTMLCollection` найденных элементов. Будут возвращены толкько те элементы, в атрибуте `class` которых содержатся все имена классов, заданные при вызове метода.

#### Выбор элементов по селекторам CSS

С помощью метода `querySelectorAll()` объекта `Document` можно выбрать элементы, соответствующие селектору CSS, и возвращает объект `NodeList`, представляющий все элементы документа, соответствующие селектору. Но в отличие от описанных выше методов выбора элементов, метод  `querySelectorAll()` возвращает не динамический объект `NodeList`, а статический. Это означает, что полученный таким образом объект `NodeList` содержит элементы, соответствующие селектору на момент вызова и не обновляемые при изменении документа.

```javascript
// Возвращает элементы, с классом num_btn
var buttons = document.querySelectorAll('.num_btn');
```

### Основные интерфейсы в DOM

 - `document.createElement(name)` - создает элемент c тем тегом, что указан в аргументе `name`.
 - `parentNode.appendChild(node)` - добавляет узел в конец списка дочерних элементов указанного родительского узла.
 - `element.innerHTML` - устанавливает или получает HTML разметку дочерних элементов.
 - `element.style.left` - используется для получения и установки инлайновых стилей
 - `element.setAttribute(name, value)` - добавляет новый атрибут или изменяет значение существующего атрибута у выбранного элемента.
 - `element.getAttribute(attributeName)` - возвращает значение указанного атрибута элемента.
 - `EventTarget.addEventListener(type, listener)` - регистрирует определенный обработчик события для EventTarget (Element, Document, Window или др.).
 - `window.onload = functionRef` - вызыает функцию functionRef, когда страница загрузится.
 - `window.dump` - выводит сообщение в консоль.
 - `window.scrollTo` - прокрутка документа до указанных координат.

### Пример создания нового содержимого

```javascript
<html>
  <head>
    <script>
    // запуск данной функции при загрузке документа
       window.onload = function() {
    // создание нескольких элементов
    // в пустой HTML странице
       heading = document.createElement("h1");
       heading_text = document.createTextNode("Big Head!");
       heading.appendChild(heading_text);
       document.body.appendChild(heading);
      }
    </script>
  </head>
  <body>
  </body>
</html>
```


## Способы вывода (отображения) информации

### Метод alert()

Метод `alert()` выводит на экран модальное окно с сообщением. Модальное окно означает, что выполнение сценария и дальнейшее взаимодействие со страницей приостанавливается до тех пор, пока не закроется данное окно, в данном случае, пока не будет нажата кнопка OK для продолжения работы.

```javascript
<script>
  alert("Hello world!");
</script>
```

### Метод document.write()

Метод `document.write()` выводит на страницу переданные ему аргументы.

Аргументов может быть любое количество, и они могут быть любых типов, при выводе они преобразуются в строки.

```javascript
<script>
  document.write("<h1>Приветствую!</h1><p>Отличного вам дня!</p>");
  document.write("Hello World!");
</script>
```

Метод `document.write()` работает только на этапе загрузки страницы.

### Метод getElementById()

Это более сложный и наиболее популярный способ вывода информации на экран. С его помощью можно изменять текстовый контент HTML страницы. Все HTML теги могут иметь идентификаторы. Именно к ним и обращается функция `getElementById()`.

`getElementById()` находит элемент по его ID, изменяет содержимое тега, при этом остальной контент остается без изменений.

Данная функция входит в пространство имен document, что требует указывать его перед самой функцией.

```javascript
<script>
  var message = "Hello world!";
  document.getElementById("id").innerHTML = message;
</script>
```

### Метод console.log()

Метод `console.log()` выводит отладочную информацию в консоль, т.е. скрывая ее от пользователей.

```javascript
<script>
  console.log("Hello world!");
</script>
```

Есть еще ряд похожих функций: `console.info()`, `console.warn()` и `console.error()`. Все они отличаются только визуально в консоли.

Один из самых простых способов отладки чего-либо в JavaScript — это логировать действия с помощью `console.log()`.

Подробнее на [Хабре](https://habr.com/ru/post/114483/).



## Ссылки

1. [Учебник JavaScript](https://professorweb.ru/my/javascript/js_theory/level1/javascript_index.php)

