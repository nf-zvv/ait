# Взаимодействие HTML5 и JavaScript

Код JavaScript на стороне клиента необходим для того, чтобы превратить статические HTML-документы в интерактивные веб-приложения. Содержимое окна браузера представлено объектом `Document`. Объект `Document` - это центральная часть большой библиотеки API-функций, называемой DOM (Document Object Model) и предназначенной для программного манипулирования содержимым документов.

## Задание:
1. Нарисовать с помощью JS шахматную доску 10х10 на Canvas с бело-синими клетками
2. При помощи JS сгенерировать таблицу, содержащую буквы русского алфавита
3. Сгенерировать с помощью JS шахматную доску 8х8 при помощи таблицы с бело-зелёными клетками
4. По нажатии на кнопку сгенерировать с помощью JS таблицу 10х10, заполненную числами от 1 до 100
5. Сгенерировать с помощью JS шахматное поле 8х8 на div элементах

## DOM (Document Object Model)

Согласно DOM-модели, документ является иерархией.

![DOM](/img/dom.jpg)

Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы. По существу, DOM соединяет веб-страницу с языками описания сценариев либо языками программирования.

Проще говоря, DOM - это представление документа в виде дерева тегов. Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Пример:

```html
<html>
<head>
  <title>My HTML Document</title>
</head>
<body>
  <h1>Heading</h1>
  <div id="div1">
    <p>P Tag 1</p>
  </div>
  <div id="div2">
    <div class="p2">P Tag 2</div>
  </div>
</body>
</html>
```

Дерево DOM для кода, представленного выше, будет выглядеть следующим образом:

![DOM Example](/img/dom_example.jpg)

Корневым элементом иерархии является `html`. У него есть два потомка. Первый - `head`, второй - `body`. И так далее, каждый вложенный тег является потомком тега выше.

Теги образуют *узлы-элементы* (element node). Текст представлен *текстовыми узлами* (text node). И то и другое - равноправные узлы дерева DOM.

Без DOM язык JavaScript не имел бы никакой модели или представления о веб-странице, HTML-документе и их элементах. Каждый элемент в документе - весь документ в целом, заголовок, таблицы внутри документа, заголовки таблицы, текст внутри ячеек таблицы - это части объектной документной модели для этого документа, поэтому все они могут быть доступны и могут изменяться с помощью DOM и скриптового языка наподобие JavaScript.

### Работа с DOM

Объект `window` представляет собой окно [браузера], содержащее DOM документ.

Для манипуляций с DOM используется объект `document`. Используя `document`, можно получать нужный элемент дерева и менять его содержание.

`document.documentElement` - самый верхний тег. В случае корректной HTML-страницы, это будет `<html>`.

`document.body` - тег `<body>`.

С вершины дерева DOM можно пойти дальше вниз. Для этого каждый DOM-узел содержит массив всех детей, отдельно - ссылки на первого и последнего ребенка и еще ряд полезных свойств.

Все дочерние элементы, включая текстовые находятся в массиве `childNodes`.

Свойства `firstChild` и `lastChild` показывают на первый и последний дочерние элементы и равны `null`, если детей нет.

Свойство `parentNode` указывает на родителя. Например, для `<body>` таким элементом является `<html>`.

Свойства `previousSibling` и `nextSibling` указывают на левого и правого братьев узла.

### Свойства элементов

У DOM-элементов есть масса свойств. Некоторые из них можно читать и устанавливать, другие - только читать.

 - `tagName` - имя тега в верхнем регистре, только для чтения;
 - `style` - Это свойство управляет стилем. Оно аналогично установке стиля в CSS. Есть общее правило замены - если CSS-атрибут имеет дефисы, то для установки `style` нужно заменить их на верхний регистр букв. Например, для установки свойства `z-index` в 1000, нужно поставить: `element.style.zIndex = 1000`;
 - `innerHTML` - содержит весь HTML-код внутри узла, и его можно менять. Свойство `innerHTML` применяется, в основном, для динамического изменения содержания страницы;
 - `className` - задает класс элемента. Оно полностью аналогично html-атрибуту `class`;
 - `onclick`, `onkeypress`, `onfocus` - функции-обработчики соответствующих событий. Например, можно присвоить обработчик события `onclick`.

### Выбор элементов документа

Обычно программа на JavaScript на стороне клиента решает свои задачи путем манипулирования одним или несколькими элементами документа. В модели DOM есть ряд способов выбора элемента:

 - по идентификатору (атрибут `id`);
 - по имени (атрибут `name`);
 - по имени тега;
 - по классу или классам CSS (атрибут `class`);
 - по соответствию заданому селектору CSS.

#### Выбор элемента по идентификатору

Каждый элемент HTML имеет атрибут `id`. Значение атрибута должно быть уникальным во всём документе. Выбрать элемент на основе уникального значения `id` можно с помощью метода `getElementById()` объекта `Document`.

```html
<div id="container"></div>
```

```javascript
var elem = document.getElementById("container");
```

#### Выбор элементов по имени

Атрибут `name` изначально был предназначен для присвоения имён элементам форм. Значение атрибута `name` используется при передаче данных формы на сервер. Как и атрибут `id`, атрибут `name` используется для присвоения имени элементу. Однако в отличие от `id`, значение атрибута `name` не обязательно должно быть уникальным. Кроме того, в отличие от атрибута `id`, атрибут `name` допустим только в подмножестве элементов HTML, в которое входят формы, элементы форм и элементы `<iframe>` и `<img>`.

```html
<form name="shipping_address">
	<input name="city" value="Izhevsk">
</form>
```

```javascript
var city = document.getElementsByName("city");
```

Метод `getElementsByName()` возвращает объект `NodeList`, который работает как массив объектов `Element`, доступный только для чтения.

Также элементы можно выбирать по имени посредством свойств объекта `Document`, имеющих соответствующие имена. Например на основе кода HTML приведенного выше:

```javascript
var city = document.shipping_address.city;
```

#### Выбор элементов по имени тега

Выбирать элементы можно также по их типу, имени тега (иногда пишут "по имени дескриптора") с помощью метода `getElementsByTagName()` объекта `Document`. Например, получить массивоподобный объект, содержащий все объекты `Element` всех элементов `<span>`, присутствующих в документе:

```javascript
var spans = document.getElementsByTagName("span");
```

Метод `getElementsByTagName()` возвращает объект `HTMLCollection`. Элементы объекта `HTMLCollection` расположены в том же порядке, что и в документе. Например, первый элемент `<p>` можно получить следующим образом:

```javascript
var firstP = document.getElementsByTagName("p")[0];
```

Метод `getElementsByTagName()` определен не только в классе `Document`, но и в классе `Element`. Это значит, что он может выбирать только элементы, являющиеся потомками элемента, через который вызван метод. Например, найти все элементы `<span>`, находящиеся в пермом элементе `<p>`:

```javascript
var firstP = document.getElementsByTagName("p")[0];
var firstSpans = firstP.getElementsByTagName("span")
```

#### Выбор элементов по классам CSS

Метод `getElementsByClassName()` возвращает массивоподобный (итерируемый) объект всех дочерних элементов, соответствующих всем из указанных имён классов.

Как и `getElementsByTagName()`, метод `getElementsByClassName()` можно вызывать либо через документ, либо через элемент.

```javascript
// Поиск всех элементов с классом warning
var w = document.getElementsByClassName("warning");
// Поиск потомков классов fatal и error элемента с идентификатором log
var log = document.getElementById("log");
var fatal = log.getElementsByClassName("falat error");
```

Метод `getElementsByClassName()` возвращает текущую `HTMLCollection` найденных элементов. Будут возвращены толкько те элементы, в атрибуте `class` которых содержатся все имена классов, заданные при вызове метода.

#### Выбор элементов по селекторам CSS

С помощью метода `querySelectorAll()` объекта `Document` можно выбрать элементы, соответствующие селектору CSS, и возвращает объект `NodeList`, представляющий все элементы документа, соответствующие селектору. Но в отличие от описанных выше методов выбора элементов, метод  `querySelectorAll()` возвращает не динамический объект `NodeList`, а статический. Это означает, что полученный таким образом объект `NodeList` содержит элементы, соответствующие селектору на момент вызова и не обновляемые при изменении документа.

```javascript
// Возвращает элементы, с классом num_btn
var buttons = document.querySelectorAll('.num_btn');
```

### Основные интерфейсы в DOM

 - `document.createElement(name)` - создает элемент c тем тегом, что указан в аргументе `name`.
 - `parentNode.appendChild(node)` - добавляет узел в конец списка дочерних элементов указанного родительского узла.
 - `element.innerHTML` - устанавливает или получает HTML разметку дочерних элементов.
 - `element.style.left` - используется для получения и установки инлайновых стилей
 - `element.setAttribute(name, value)` - добавляет новый атрибут или изменяет значение существующего атрибута у выбранного элемента.
 - `element.getAttribute(attributeName)` - возвращает значение указанного атрибута элемента.
 - `EventTarget.addEventListener(type, listener)` - регистрирует определенный обработчик события для EventTarget (Element, Document, Window или др.).
 - `window.onload = functionRef` - вызыает функцию functionRef, когда страница загрузится.
 - `window.dump` - выводит сообщение в консоль.
 - `window.scrollTo` - прокрутка документа до указанных координат.

### Пример создания нового содержимого

#### Первый способ создания динамического содержимого

Формируем строку и выводим ее в контейнер при помощи свойства innerHTML.

```javascript
<html>
  <head>
    <script>
    // запуск данной функции при загрузке документа
      window.onload = function() {
        let container = document.getElementById("container");

        let elem;

        for(let i=0; i<10; i++){
			elem += '<input type="button" class="num_btn" value="' + i + '">';
		}
		container.innerHTML = elem;
      }
    </script>
  </head>
  <body>
    <div id="container"></div>
  </body>
</html>
```

#### Второй способ создания динамического содержимого

Простой пример:

```javascript
<html>
  <head>
    <script>
    // запуск данной функции при загрузке документа
       window.onload = function() {
    // создание нескольких элементов
    // в пустой HTML странице
       heading = document.createElement("h1");
       heading_text = document.createTextNode("Big Head!");
       heading.appendChild(heading_text);
       document.body.appendChild(heading);
      }
    </script>
  </head>
  <body>
  </body>
</html>
```

Более сложный пример:

```javascript
<html>
  <head>
    <script>
    // запуск данной функции при загрузке документа
       window.onload = function() {
       	 let container = document.getElementById("container");
       	 // Создаем фрагмент документа
         let tree = document.createDocumentFragment();
         // Наполняем его вновь создаваемыми элементами
         for(let i=0; i<10; i++){
           let btn = document.createElement("input");
           btn.setAttribute("type", "button");
           btn.setAttribute("class", "num_btn");
           btn.setAttribute("value", i);
           tree.appendChild(btn);
         }
         // Помщаем фрагмент в контейнер
         container.appendChild(tree);
     }
    </script>
  </head>
  <body>
    <div id="container"></div>
  </body>
</html>
```

### Присваивание обработчиков событий элементам

#### Первый вариант

При помощи метода `getElementsByClassName()` получаем коллекцию найденных элементов (объект `HTMLCollection`)
Используя свойство `length` и метод `item()` получаем доступ к индивидуальным элементам коллекции.

```javascript
// Ищем все кнопки с необходимым классом
let buttons = document.getElementsByClassName('num_btn');
// Вещаем обработчики в цикле
for(let i=0; i<10; i++){
	buttons.item(i).onclick = button_press;
}
```

#### Второй вариант

Метод `querySelectorAll()` возвращает `NodeList`, т.е. список всех найденных узлов.
`NodeList` имеет метод `forEach(func)`, который выполняет указанную функцию `func` один раз для каждого элемента `NodeList`.

`EventTarget.addEventListener(eventType, listener)` регистрирует обработчик `listener` для события `eventType`, вызванного на `EventTarget`.

```javascript
document.querySelectorAll(".num_btn").forEach(function(item){item.addEventListener('click', button_press)});
```

